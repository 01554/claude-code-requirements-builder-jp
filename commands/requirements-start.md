# 要件収集の開始

以下の要件収集を開始: $ARGUMENTS

## 完全なワークフロー:

### フェーズ 1: 初期セットアップとコードベース分析
1. タイムスタンプベースのフォルダを作成: requirements/YYYY-MM-DD-HHMM-[slug]
2. $ARGUMENTS からスラグを抽出（例: "add user profile" → "user-profile"）
3. 初期ファイルを作成:
   - ユーザーのリクエストを含む 00-initial-request.md
   - ステータス追跡用の metadata.json
4. requirements/.current-requirement を読み込み、フォルダ名で更新
5. mcp__RepoPrompt__get_file_tree（利用可能な場合）を使用して全体構造を理解:
   - 高レベルのアーキテクチャ概要を取得
   - 主要なコンポーネントとサービスを特定
   - 技術スタックを理解
   - パターンと慣習を記録

### フェーズ 2: コンテキスト発見質問
6. 問題領域を理解するための最も重要な5つのyes/no質問を生成:
   - コードベース構造に基づいた質問
   - ユーザーインタラクションとワークフローに関する質問
   - ユーザーが現在使用している類似機能に関する質問
   - 作業対象のデータ/コンテンツに関する質問
   - 外部統合やサードパーティサービスに関する質問
   - パフォーマンスやスケールの期待値に関する質問
   - スマートデフォルト付きですべての質問を 01-discovery-questions.md に書く
   - スマートデフォルトオプションを提案して一度に1つずつ質問を開始
   - すべての質問を聞いた後でのみ、受け取った回答を 02-discovery-answers.md に記録し、metadata.json を更新。それ以前は記録しない。

### フェーズ 3: ターゲットコンテキスト収集（自律的）
7. すべての発見質問に回答した後:
   - 発見回答に基づいて特定のファイルを見つけるために mcp__RepoPrompt__search（利用可能な場合）を使用
   - 関連コードをバッチで読み込むために mcp__RepoPrompt__set_selection と read_selected_files（利用可能な場合）を使用
   - 類似機能とパターンを深く探究
   - 特定の実装詳細を分析
   - ベストプラクティスやライブラリドキュメントのために WebSearch や context7 を使用
   - 以下を含む発見事項を 03-context-findings.md に文書化:
     - 変更が必要な特定のファイル
     - 従うべき正確なパターン
     - 詳細に分析された類似機能
     - 技術的な制約と考慮事項
     - 特定された統合ポイント

### フェーズ 4: エキスパート要件質問
8. コードベースを知っているシニア開発者のように質問:
   - 最も重要な未回答の詳細なyes/no質問トップ5を 04-detail-questions.md に書く
   - コードを何も知らないプロダクトマネージャーに話すかのような質問にする
   - これらの質問は、コードを深く理解した上で、期待されるシステム動作を明確にするためのもの
   - コードベースのパターンに基づいたスマートデフォルトを含める
   - 一度に1つずつ質問する
   - すべての質問を聞いた後でのみ、受け取った回答を 05-detail-answers.md に記録

### フェーズ 5: 要件ドキュメント作成
9. 包括的な要件仕様を 06-requirements-spec.md に生成:
   - 問題の説明とソリューション概要
   - すべての回答に基づく機能要件
   - 特定のファイルパスを含む技術要件
   - 実装ヒントと従うべきパターン
   - 受け入れ基準
   - 未回答の質問に対する前提条件

## 質問フォーマット:

### 発見質問（フェーズ 2）:
```
## Q1: ユーザーはこの機能をビジュアルインターフェースを通じて操作しますか？
**不明な場合のデフォルト:** はい（ほとんどの機能には何らかのUIコンポーネントがあります）

## Q2: この機能はモバイルデバイスで動作する必要がありますか？
**不明な場合のデフォルト:** はい（モバイルファーストが標準的なプラクティスです）

## Q3: この機能は機密またはプライベートなユーザーデータを扱いますか？
**不明な場合のデフォルト:** はい（デフォルトでセキュアにする方が良いです）

## Q4: ユーザーは現在、この問題に対して回避策を持っていますか？
**不明な場合のデフォルト:** いいえ（これが新しいニーズを解決すると仮定）

## Q5: この機能はオフラインで動作する必要がありますか？
**不明な場合のデフォルト:** いいえ（ほとんどの機能は接続が必要です）
```

### エキスパート質問（フェーズ 4）:
```
## Q7: services/UserService.ts の既存の UserService を拡張すべきでしょうか？
**不明な場合のデフォルト:** はい（アーキテクチャの一貫性を保ちます）

## Q8: db/migrations/ に新しいデータベースマイグレーションが必要でしょうか？
**不明な場合のデフォルト:** いいえ（類似機能がスキーマ変更を必要としないことに基づく）
```

## 重要なルール:
- スマートデフォルト付きのyes/no質問のみ
- 一度に1つの質問
- 質問する前にすべての質問をファイルに書く
- 要件に焦点を当てる（実装はしない）
- 詳細フェーズでは実際のファイルパスとコンポーネント名を使用
- 各デフォルトが理にかなっている理由を文書化
- 推奨されるツールがインストールされていないか利用不可の場合は、利用可能なツールを使用

## メタデータ構造:
```json
{
  "id": "feature-slug",
  "started": "ISO-8601-timestamp",
  "lastUpdated": "ISO-8601-timestamp",
  "status": "active",
  "phase": "discovery|context|detail|complete",
  "progress": {
    "discovery": { "answered": 0, "total": 5 },
    "detail": { "answered": 0, "total": 0 }
  },
  "contextFiles": ["paths/of/files/analyzed"],
  "relatedFeatures": ["similar features found"]
}
```

## フェーズ遷移:
- 各フェーズの後、アナウンス: "フェーズ完了。[次のフェーズ]を開始します..."
- 次のフェーズに移る前にすべての作業を保存
- ユーザーはいつでも /requirements-status で進捗を確認可能
